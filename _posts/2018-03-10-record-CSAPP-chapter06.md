---
layout:     post
title:      reading-note-csapp
date:       2018-03-10 21:48:00
author:     "Hou"
header-img: "img/post-bg-computer-science.jpg"
tags:
    - note
    - csapp
---
第六章-存储器层次结构小结
============


### 6.1 存储技术


*6.1.1 随机访问存储器*

随机访问存储器（Random-Access Memory, RAM）分为两类：静态的和动态的。

1. 静态RAM（SRAM）比动态RAM（DRAM）更快，但也贵很多。SRAM用来作为高速缓存存储器，既可以在CPU芯片上，也可以在片下。DRAM用来作为主存以及图形系统的帧缓冲区。SRAM将每个位存储在一个双稳态的（bistable）存储器单元里。每个单元是用一个六晶体管电路来实现的。这个电路有这样一个属性，它可以无期限的保持在两个不同的电压配置或状态之一。
![](/img/post/post-2018-02-28-14.jpg)

2. DRAM将每个位存储为对一个电容的充电。这个电容非常小，通常只有大约30毫微微法拉（femtofarad）——30 * 10^(-15) 法拉。DRAM存储器可以制造的非常密集——每个单元由一个电容和一个访问晶体管组成。但是，与SRAM不同，DRAM存储器单元对干扰非常敏感。当电容的电压被扰乱之后，它就永远不会回复了。所以内存系统必须周期性地通过独处，然后重写来刷新内存每一位。一个传统的DRAM芯片由d个超单元（supercell）组成，每个超单元由w个DRAM单元组成。读取超单元的方式是，先由内存控制器发送行地址，DRAM将这行内容复制到内部行缓冲区，再由控制器发送列地址，DRAM再从缓冲区中复制超单元的w位，并发送到内存控制器。

![](/img/post/post-2018-02-28-15.jpg)

3. 内存模块，DRAM芯片封装在内存模块（memory module）中，它查到主板的扩展槽上。Core i7 系统使用的240个引脚的双列直插内存模块（Dual Inline Memory Module，DIMM），它以64位为块传送数据到内存控制器和从内存控制器传出数据。要去除内存地址A处的一个字，内存控制器将A转换成一个超单元地址（i,j），并将它发送到内存模块，然后内存模块再将i和j广播到每个DRAM。作为响应，每个DRAM输出它的（i,j）超单元的8位内容。模块中的电路手机这些输出，并把它们合并成一个64位字，再返回给内存控制器。通过将多个内存模块连接到控制器，能够聚合成主存。

4. 增强的DRAM：

- 快页模式DRAM（Fast Page Mode DRAM， FPM DRAM)允许对同一行连续地址访问可以直接从行缓冲区得到服务，而不必使用一个丢弃剩余的。

- 扩展数据输出DRAM（Extended Data Out DRAM， EDO DRAM）。它允许各个CAS（Column Access Strobe）信号在时间上靠得更紧密一点。

- 同步DRAM（Synchronous DRAM，SDRAM）用与驱动内存控制器相同的外部时钟信号的上升沿来代替许多这样的控制信号。

- 双倍数据速率同步DRAM（Double Data-Rate Synchronous DRAM， DDR SDRAM）是对SDRAM的一种增强，通过使用两个时钟沿作为控制信号，从而是速度翻倍。

- 视频RAM（Video RAM，VRAM）用在图形系统的帧缓冲区中。VRAM的思想与FPM DRAM类似，主要区别是VRAM的输出是通过依次对内部缓冲区的整个内容进行移位得到的;VRAM允许对内存并行的读和写。

5. 非易失性存储器

如果断电，DRAM和SRAM会丢失它们的信息，从这个意义上说，它们时易失的（volatile）。另一方面，非易失性存储器（nonvolatile memory）即使是在关电后，仍然保存着它们的信息。虽然ROM中有的类型即可以读也可以写，但他们整体上都被称为只读存储器（Read-Onlu Memory，ROM）。

- PROM（Programmable ROM，可编程ROM）只能被编程一次。PROM的每个存储器单元有一种熔丝（fuse），只能用高电流熔断一次。

- 可擦写可编程ROM（Erasable Programmable ROM，EPROM）有一个透明的石英窗口，允许光到达存储单元。紫外线光照射过窗口，EPROM单元就被清除为0。对它编程是通过使用一种把1写入EPROM的特殊设备来完成的。其能够被擦除和重编程的次数的数量级可以达到1000次。电子可擦除PROM（Electrically Erasable PROM，EEPROM）类似于EPROM，但是它不需要一个物理上独立的编程设备，因此可以直接在音质电路卡上编程。EEPROM能够被编程的次数的数量级可以达到10^5次。

- 闪存（flash memory）是一类非易失性存储器，给予EEPROM，它以及成为了一种重要的存储技术。

- 固件（firmware）是存储在ROM设备中的程序。当一个计算机系统通电后，它会运行存储在ROM的固件。一些系统在固件中提供了少了基本的输入和输出函数————例如PC的BIOS历程。复杂的设备，如图形卡和磁盘驱动控制器，也依赖固件翻译来自CPU的I/O请求。

6. 访问主存

数据流通过总线（bus）在处理器和DRAM主存之间来来回回。每次CPU和贮存之间的数据传送都是通过一系列步骤来完成的，这些步骤成为总线事务（bus transaction）。读事务（read transaction）从主存传送数据到CPU。写事物（write transaction）从CPU传送数据到主存。控制线携带的信号会同步事务，并标识出当前正在被执行的事务的类型。

![](/img/post/post-2018-02-28-16.jpg)

如果要将地址A的内容加载到寄存器中，CPU芯片上成为总线接口（bus interface）的电路在总线上发起读事务。读事务由三个步骤组成。首先，CPU将抵制A放到系统总线上。I/O桥将信号传递到内存总线。接下来，主存感觉到内存总线上的地址信号，从内存总线读地址，从DRAM读出数据字，并将数据写到内存总线。I/O桥将内存总线信号翻译成系统总线信号，然后沿着系统总线传递。最后CPU感觉到系统总线上的数据，从总线上读数据，并将数据复制到寄存器。


*6.1.2 磁盘存储*

磁盘读信息的时间为毫秒级，比DRAM慢了10万倍，比SRAM慢了100万倍。

1. 磁盘构造

磁盘是由盘片（platter）构成的。每个盘片由两面或者成为表面（surface），表面覆盖着磁性记录材料。盘片中央有一个可以旋转的主轴（spindle），它使得盘片以固定的旋转速率（rotational rate）旋转，通常是5400~15000转每分钟（Revolution Per Minute，RPM）。磁盘通常包含一个或多个这样的盘片，封装在一个密封的容器内。

每一个表面是由一组成为磁道（track）的同心圆组成的。每个磁道被划分为一组扇区（sector）。每个扇区包含相等数量的数据位（通常是512字节），这些数据编码在扇区上的磁性材料中。扇区之间由一些间隙（gap）分隔开。间隙存储用来标识扇区的格式化位。

磁盘是由一个或多个叠放在一起的盘片组成的，他们被封装在一个密封的包装里。整个装置通常被称为磁盘驱动器（disk drive），我们通常简称为磁盘（disk）。有时我们会称磁盘为旋转磁盘（rotating disk），以使之区别于给予闪存的固态硬盘（SSD），SSD是没有移动部分的。

磁盘制造商通常用术语柱面（cylinder）来描述多个盘片驱动器的构造，这里，柱面是所有盘片表面上到主轴中心的距离相等的磁道的集合。

![](/img/post/post-2018-02-28-17.jpg)

2. 磁盘容量

磁盘容量是由以下技术因素决定的：

- 记录密度（recording density）（位/英寸），磁道一英寸的段中可以放入的位数。

- 磁道密度（track density）（道/英寸），从盘片中心出发半径上一英寸的段内可以有的磁道数。

- 面密度（areal density）（位/平方英寸），记录密度与磁道密度的乘积。

现代大容量磁盘使用一种称为多区记录（multiple zone recording）的技术，在这种技术中，柱面的集合被分割成不相交的子集合，成为记录区（recording zone）。每个区包含一组连续的柱面。一个区中的每个柱面中的每条磁道都有相同数量的扇区，这个扇区的数量是由该区最里面的磁道所能包含的扇区数确定的。

3. 磁盘操作

磁盘用读/写头（read/write head）来读写存储在磁性表面的位，而读写头连接到一个传动臂（actuator arm）一端。通过沿着半径轴前后移动这个传动臂，驱动器可以将读/写头定位在盘面上的任何磁道上。这样的机械运动成为寻道（seek）。一旦读/写头定位到了期望的磁道上，那么当磁道上的每一个位通过它的下面时，读/写头可以读写这个位的值。有多个盘片的磁盘针对每个盘面都有一个独立的读/写头，垂直排列，一致行动。

![](/img/post/post-2018-02-28-18.jpg)

磁盘以扇区大小的块来读写数据。对扇区的访问时间（access time）有三个主要的部分：寻道时间（seek time）、旋转时间（rotational latency）和传送时间（transfer time）：

- 寻道时间，读/写头定位到包含目标扇区的磁道上的时间。它依赖于读/写头以前的位置和传动臂在盘面上移动的速度。一次寻道时间通常为3~9ms。

- 旋转时间，一旦定位成功，驱动器等到目标扇区的第一个位旋转到读/写头下。这个步骤的性能依赖于读/写头到达目标扇区时盘面的位置以及磁盘的旋转速度。

- 传送时间，依赖于旋转速度和每条磁道的扇区数目。

主要的时间是用在寻道和旋转上，传送几乎不用时间。

4. 逻辑磁盘块

磁盘封装中有一个小的硬件/固件设备，称为磁盘控制器，维护着逻辑块号和实际（物理）磁盘扇区之间的映射关系（把逻辑块号翻译为盘面，磁道，扇区的三元组，唯一的标识了对应的物理扇区）。

5. 连接I/O设备

例如图形卡、显示器、鼠标、键盘、磁盘这样的I/O设备，都是通过I/O总线，连接到CPU和主存的。系统总线和内存总线是与CPU相关的，与他们不同，I/O总线设计与底层CPU无关。

I/O总线可连接设备有以下三种：

- 通用串行总线（Universal Serial Bus，USB）（用了这么多年总算知道USB的全称是什么了。。）控制器是一个连接到USB总线的设备中转机构，一个广泛使用的标准，链接各种外围I/O设备。

- 图形卡（或适配器）包含硬件和软件逻辑，它们负责代表CPU在显示器上画像素。

- 主机总线适配器将一个或多个磁盘连接到I/O总线，使用的是一个特别的主机总线接口定义的通信协议。两个最常用的接口是SCSI和SATA。前者通常比后者更快更贵，可以支持多个磁盘驱动器，但SATA只支持一个驱动器。

![](/img/post/post-2018-02-28-19.jpg)

其他设备如网络适配器，可以通过将适配器插入到主板上空的扩展槽中，从而连接到I/O总线。

6. 访问磁盘

CPU使用一种称为内存映射I/O（memory-mapped I/O）的技术来向I/O设备发射命令。在使用内存映射I/O的系统中，地址空间有一块地址是为与I/O设备通信保留的。每个这样的地址成为一个I/O端口（I/O port）。当一个设备连接到总线时，它与一个或多个端口相关联（或它被映射到一个或多个端口）。

如果磁盘控制器映射到端口0xa0。随后CPU发起磁盘读，磁盘控制器收到命令后，将内容直接传送到主存，设备可以自己执行读或者写总线事务而不需要CPU干涉，这个过程被称为直接内存访问（Direct Memory Access，DMA）。

传送完成后，磁盘控制器通过给CPU发送一个中断信号来通知CPU。基本思想是中断会发信号到CPU芯片的一个外部引脚上。这会导致CPU暂停它当前正在做的工作，跳转到一个操作系统例程。该程序会记录下I/O以及完成，然后控制返回到CPU被中断的地方。


*6.1.3 固态硬盘*

固态硬盘（Solid State Disk，SSD）是一种基于闪存的存储技术。SSD封装插到I/O总线上标准硬盘插槽（通常是USB或SATA）中，行为就和其他硬盘一样，处理来自CPU的读写逻辑磁盘块的请求。一个SSD封装由一个或多个闪存芯片和闪存翻译层（flash translation layer）组成，闪存芯片替代传统旋转磁盘中的机械驱动器，而闪存翻译层是一个硬件/固件设备，扮演与磁盘控制器相同的角色，将对逻辑块的请求翻译成对底层物理设备的访问。

![](/img/post/post-2018-02-28-20.jpg)

读SSD比写要快，性能差别是由底层闪存基本属性决定的。一个闪存由B个块的序列组成，每个块由P页组成。通常页的大小时512字节~4KB，块是由32~128页组成的，块的大小为16KB~512KB。数据是以页为单位读写的。只有在一页所属的块整个被擦除之后，才能写这一页。不过擦除是以块为单位擦除的，100000次重复写之后，块就会磨损坏。

随机写很慢，首先擦除需要的时间是1ms级的，比访问所需时间高一个数量级；其次如果写操作试图修改一个包含已经有数据的页p，那么这个块中所有带有用数据的页都必须被复制到一个新的块，然后才能进行对页p的写（那复制后的块用来干嘛呢。。）。

相比旋转磁盘，SSD的优点是，由半导体存储器构成，没有移动的部件，因而随机访问时间比旋转磁盘要快，能耗更低，同时也更结实。缺点是反复写后会磨损。闪存翻译层的平均寿命（wear leveling）逻辑试图通过将擦除平均分布在所有的块上来最大化每个块的寿命。其次，SSD每字节比旋转磁盘贵大约30倍，一次常用的存储容量比旋转磁盘小100倍。


*6.1.4 存储技术趋势*

增加密度比降低访问时间容易得多。

![](/img/post/post-2018-02-28-21.jpg)


### 6.2 局部性

一个好的计算机程序常常具有良好的局部性（locality），即他们倾向于引用邻近于其他最近引用过的数据项的数据项，或者最近引用过的数据项本身。这种倾向性，被称为局部性原理（principle of locality）。

局部性通常有两种不同的形式：时间局部性（temporal locality）和空间局部性（spatial locality）。一个是时间上邻近，一个是空间上邻近。

*6.2.1 对程序数据引用的局限性*

我们称步长为1的引用模式为顺序引用模式（sequential reference pattern）。一个连续的向量中，每隔k个元素进行访问，就成为步长为k的引用模式（strike-k reference pattern）。一般而言，随着步长的增加，空间局部性下降。

*6.2.3 局部性小结*

- 重复引用相同变量的程序有良好的时间局部性。

- 对于具有步长为k的引用模式的程序，步长越小，空间局部性越好。

- 循环体越小，循环迭代次数越多，局部性越好（那这和循环展开不就矛盾了？）。


### 6.3 存储器层次结构

![](/img/post/post-2018-02-28-22.jpg)

*6.3.1 存储器层次结构中的缓存*

一般而言，高速缓存（cache）是一个小而快速的存储设备，它作为存储在更大、也更慢的设备中的数据对象的缓冲区域。使用高速缓存的过程称为缓存（caching）。

存储器层次结构的中心思想是，没一层都缓存来自较低一层的数据对象。

数据总是以块大小为传送单元（transfer unit）在第k层和第k+1层之间来回复制的。虽然在层次结构中任何一对相邻的层次之间块大小是固定的，但是其他的层次对之间可以有不同的块大小。一般而言，层次结构中较低层的设备的访问时间较长，因此为了补偿这些较长的访问时间，倾向于使用较大的块。

1. 缓存命中

当程序需要第k+1层的某个数据对象d时（怎么知道是在第几层的？），它首先在当前存储在第k层的一个块中查找d。如果d缓存在第k层中，那就是缓存命中（cache hit）。

2. 缓存不命中

如果第k层不存在缓存数据对象d，那么就是我们说的缓存不命中（cache miss）。当没有命中时，第k层的缓存从第k+1层缓存中去除包含d的那个块，如果k层缓存已经满了，可能就会覆盖现存的一个块。

覆盖的过程称为替换（replacing）或驱逐（evicting）这个块。被驱逐的块被称为牺牲块（victim block）。决定该替换哪个块是由缓存的替换策略（replacement policy）来控制的。

3. 缓存不命中的种类

如果第k层的缓存是空的，我们称他为冷缓存（cold cache），此类不命中称为强制不命中（compulsory miss）或冷不命中（cold miss）。这种不命中会在缓存暖身之后消失。

只要发生了不命中，第k层的缓存就必须执行某个放置策略（placement policy），确定从k+1层中取出的块放在那。最灵活的替换策略是任意块。对于高层的缓存，这个策略通常很昂贵，因为定位起来代价很高。

因此，硬件缓存通常使用的策略是将第k+1层的某个块限制放置在第k层块的一个小的子集中。例如，第k+1层的块0，4，8会映射到第k层的块0（这样做的好处是带有连续数据的块不容易被互相驱逐）。这种限制性的放置策略会引起一种不命中，称为冲突不命中（conflict miss），在这种情况中，缓存足够大，能够保存被引用的数据对象，但是因为这些对象会映射到同一个缓存块，缓存会一直不命中。如程序请求块0，再块8，再块0，以此类推，在第k层的缓存中，对这两个块的每次引用都会不命中，即使这个缓存总共可以容纳4个块。

程序通常是按照一系列阶段来运行的，一个阶段需访问的块的集合称为这个阶段的工作集（working set）。当工作集的大小超过缓存的大小时，缓存会经历容量不命中（capacity miss）（缓存太小了）。

### 6.4 高速缓存存储器

*6.4.1 通用的告诉缓存存储器结构*

![](/img/post/post-2018-02-28-23.jpg)

*6.4.2 直接映射高速缓存*

1. 直接映射高速缓存中的组选择

高速缓存从w的地址中间抽取出s个组索引位。这些位被解释成一个对应于一个组号的无符号整数。

2. 直接映射高速缓存的行匹配

当且仅当设置了有效位，而且高速缓存行中的标记与w的地址中的标记相匹配时，这一行中包含w的一个副本。如果有效位没有设置，或者标记不相匹配，那么我们就得到一个缓存不命中。

3. 直接映射高速缓存中的字选择

块偏移位提供了所需要的字的第一个字节的偏移。

![](/img/post/post-2018-02-28-24.jpg)

4. 直接映射高速缓存中不命中时的行替换

从下一层取出被请求的块，存储在组索引位指示的组中的一个高速缓存行中。

5. 直接映射高速缓存中的冲突不命中

解决方法是人为在中间增加B字节填充，使他们的高速缓存块的组不重叠。

*6.4.3 组相联高速缓存*

不同于直接映射之处在于，组相联高速缓存一个组有多个高速缓存行

*6.4.4 全相联高速缓存*

全由行组成，但只适合做小的高速缓存

*6.6.6 一个真实的高速缓存层次结构的解剖*

高速缓存分为存放指令的i-cache和存放程序数据的d-cache，前者通常只是可读的。

![](/img/post/post-2018-02-28-25.jpg)


### 6.5 编写高速缓存友好的代码

