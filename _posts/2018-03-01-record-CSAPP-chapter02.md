---
layout:     post
title:      reading-note-csapp
date:       2018-03-01 21:48:00
author:     "Hou"
header-img: "img/post-bg-computer-science.jpg"
tags:
    - note
    - csapp
---
第二章-信息的表示和处理小结
============


### 2.1 信息存储

机器级程序将内存视为一个非常大的字节数组，称为虚拟内存（virtual memory）。内存的每个字节都有一个唯一的数字来表示，称为它的地址，所有可能地址的集合就成为虚拟地址空间（virtual address space）。这个虚拟地址空间只是一个展现给机器级程序的概念性映像。

*2.1.1 十六进制表示法*

一个字节由8位组成，值域为0~255，二进制表示法过于冗长，而十进制表示法与位模式的互相转换很麻烦，因此用十六进制（hexadecimal）表示法来替代。

*2.1.2 字数据大小*

字长（word size）指明指针数据的标称大小（nominal size）。字长决定了虚拟地址空间的最大大小。

*2.1.3 寻址和字节顺序*

多字节对象被存储为连续的字节序列，对象的地址为所使用字节中最小的地址。

*2.1.4 表示字符串*

C语言中字符串被编码为一个以null字符结尾的字符数组，每个字符都由某个标准编码来表示，最常见的是ASCII字符码。

*2.1.5 表示代码*

不同的机器类型使用不同的且不兼容的指令和编码方式。即使是完全一样的进程，运行在不同的操作系统时也会有不同的编码规则，因此二进制代码是不兼容的。二进制代码很少能在不同机器和操作系统组合之间移植。计算机系统的一个基本概念就是，从机器的角度来看，程序仅仅只是字节序列。

*2.1.6 布尔代数简介*

*2.1.7 C语言中的位级运算*

位级运算的一个常见用法就是实现掩码运算，这里掩码是一个位模式，表示从一个字中选出的位的集合。如x=0x89ABCDEF，x&0xFF=0x000000EF。

*2.1.8 C语言中的逻辑运算*

*2.1.9 C语言中的移位运算*

![](/img/post/post-2018-02-28-07.jpg)


### 2.2 整数表示

*2.2.1 整型数据类型*

*2.2.2 无符号数的编码*

*2.2.3 补码编码*

补码最高有效位为符号位，1表示负，0表示非负

*2.2.4 有符号数和无符号数之间的转换*

这几章节都是给数学盲看的，下略。


### 2.3整数运算

*2.3.1 无符号加法*

对于小于2的w次方的非负整数x，y，对x+y的位级表示，简单丢弃任何权重大于2的w-1次方的位就可以计算出和模2的w次方。如12+9的和为21，模16为5，是12和9在2的4次方的和。

*2.3.2 补码加法*

比无符号加法多个负数溢出情况，位级减一。

*2.3.6 乘以常数*

在大多数机器上，正数乘法指令相当慢，需要10个或者更多的时钟周期，然而其他整数运算只需要1个时钟周期，因此试着用移位和加法运算的组合来代替乘以常数因子的乘法。如x * 14=x<<2^4-x<<2^1

*2.3.7 除以2的幂*

在大多数机器上，整数除法要比整数乘法更慢————需要30个或者更多的时钟周期。


### 2.4 浮点数

*2.4.2 IEEE浮点表示*
IEEE浮点标准用$$V=(-1)^S * M * 2^E$$的形式来表示一个数。

![](/img/post/post-2018-02-28-08.jpg)

- 规格化的值：exp的位模式既不全为0，也不全为1（单精度255，双精度2047），阶码字段被解释为以偏置形式表示的有符号整数（E=e-Bias)。小数字段frac被解释为描述小数值f，其中0<=f<1，尾数定义为1+f。（理解成右移就能想明白为什么要+1）

- 非规格化的值：当阶码域为全0时，所表示的数是非规格化形式。阶码值是E=1-Bias，尾数是M=f

- 特殊值：阶码全1，小数域全0，表示无穷。当小数域为非零时，结果值是“NaN”

![](/img/post/post-2018-02-28-09.jpg)

