---
layout:     post
title:      reading-note-csapp
date:       2018-03-14 21:48:00
author:     "Hou"
header-img: "img/post-bg-computer-science.jpg"
tags:
    - note
    - csapp
---
第九章-虚拟内存小结
============

虚拟内存提供了三个重要的能力：

1. 它将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并更具需要在磁盘和主存之间来回传送数据，通过这种方式，它高效的使用了主存。

2. 它为每个进程提供了一致的地址空间，从而简化了内存管理。

3. 它保护了每个进程的地址空间不被其他进程破坏。

### 9.1 物理和虚拟寻址

计算机系统的主存被组织成一个由M个连续的字节大小的单元组成的数组。每字节都有一个唯一的物理地址（Physical Address）。给定这种简单的结构，CPU访问内存的最自然的方式就是使用物理地址。我们把这种方式称为物理寻址（physical addressing）。

现代处理器使用的是一种称为虚拟寻址（virtual addressing）的寻址形式。CPU通过生成一个虚拟地址（Virtual Address）来访问主存，这个虚拟地址被送到内存之前先转换成适当的物理地址。转换的任务叫做地址翻译（address translation）。CPU芯片上叫做内存管理单元（Memory Management Unit）的专用硬件，利用存放在主存中的查询表来动态翻译虚拟地址。（为什么觉得是在脱裤子放屁呢？）


### 9.2 地址空间

地址空间（address space）是一个非负整数地址的有序集合。如果地址空间中的整数是连续的，那么我们说它是一个线性地址空间（linear address space）。一个有N=2^n个地址的地址空间称为n位地址空间。

一个系统还有一个物理地址空间（physical address space），对应于系统中物理内存M个字节，M不要求是2的幂。


### 9.3 虚拟内存作为缓存的工具

VM系统通过将虚拟内存分割为虚拟页（Virtual Page）大小固定的块，每个虚拟页的大小为P=2^p字节。类似的，物理内存被分割为物理页（Physical Page），大小也为P字节。

在任意时刻，虚拟页面的集合都分为三个不相交的子集：

- 未分配的：VM系统还未分配（或创建）的页。未分配的块没有任何数据和它们相关联，因此也就不占用任何磁盘空间。

- 缓存的：当前已缓存在物理内存中的已分配页。

- 未缓存的：未缓存在物理内存中的已分配页。

*9.3.1 DRAM缓存的组织结构*

DRAM比SRAM慢大约10倍，磁盘比DRAM慢大约100000多倍。因此DRAM缓存中的不命中比起SRAM缓存中的不命中要昂贵的多。因此虚拟页往往很大，通常是4KB~2MB，DRAM缓存是全相联的，即任何虚拟页都可以放置在任何的物理页中。

*9.3.2 页表*

页表是一个存放在物理内存中的数据结构，它将虚拟页映射到物理页。每次地址翻译硬件将一个虚拟地址转换为物理地址时，都会读取页表。

页表就是一个页表条目（Page Table Entry，PTE）的数组。虚拟地址空间中的每个页在页表中一个固定偏移量处都有一个PTE。我们假设每个PTE是由一个有效位（valid bit）和一个n位地址字段组成的。有效位表明了该虚拟页当前是否被缓存在DRAM中。

*9.3.4 缺页*

如果CPU引用了某个虚拟页中的一个字，而这个虚拟页没有被缓存在DRAM中，称为缺页。此时缺页异常会调用内核中的缺页异常处理程序，该程序会选择一个牺牲页，如果此牺牲页已经被修改了，内核就会将它复制回磁盘。接下来，内核从磁盘复制需要的虚拟页到内存中的物理页，更新PTE对应位置，随后返回。返回后，会重新启动导致缺页的指令，该指令会把导致缺页的虚拟地址重发送到地址翻译硬件。


### 9.4 虚拟内存作为内存管理的工具

操作系统为每个进程提供了一个独立的页表，因而也就是一个独立的虚拟地址空间。

![](/img/post/post-2018-02-28-37.jpg)


### 9.5 虚拟内存作为内存保护的工具

现代计算机系统必须为操作系统提供手段来控制对内存系统的访问。不应该允许一个用户进程修改它的只读代码段。而且也不应该允许它读或修改任何内核中的代码和数据结构。不应该允许它读或者写其他进程的私有内存，并且不允许它修改任何与其他进程共享的虚拟页面，除非所有的共享者都显式地允许它这么做。


### 9.6 地址翻译

![](/img/post/post-2018-02-28-38.jpg)

![](/img/post/post-2018-02-28-39.jpg)

*9.6.2 利用TLB加速地址翻译*

翻译后备缓冲器（Translation Lookaside Buffer，TLB）是一个小的、虚拟寻址的缓存，其中每一行都保存着一个由单个PTE组成的块。

*9.6.3 多级页表*

![](/img/post/post-2018-02-28-40.jpg)


### 9.8 内存映射

Linux通过将一个虚拟内存区域与一个磁盘上的对象关联起来，以初始化这个虚拟内存区域的内容成为内存映射（memory mapping）。虚拟内存区域可以映射到两种类型的对象中的一种：

1. Linux文件系统中的普通文件：一个区域可以映射到一个普通磁盘文件的连续部分，例如一个可执行目标文件。文件区（sectino）被分成页大小的片，每一片包含一个虚拟页面的初始内容。

2. 匿名文件：一个区域也可以映射到一个匿名文件，匿名文件是由内核创建的，包含的全是二进制零。CPU第一次引用这样一个区域内的虚拟页面时，内核就在物理内存中找到一个合适的牺牲页面，如果该页面被修改过，就将这个页面换出来，用二进制零覆盖牺牲页面并更新页表，将这个页面标记为是驻留在内存中的。

*9.8.1 再看共享对象*

一个对象可以被映射到虚拟内存的一个区域，要么作为共享对象，要么作为私有对象。如果一个进程将一个共享对象映射到它的虚拟地址空间的一个区域内，那么这个进程对这个区域的任何写作，对于那些也把这个共享对象映射到它们虚拟内存的其他进程而言，也是可见的。而且，这个变化也会反映在磁盘上的原始对象中。

相反，映射到私有对象的改变，对于其他进程来说是不可见的，并且进程对这个区域所做的任何写操作都不会翻译在磁盘上的对象中。


### 9.9 动态内存分配

动态内存分配器维护着一个进程的虚拟内存区域，称为堆（heap）。堆紧接在会初始化的数据区域后开始，并向上生长。对于每个进程，内核维护着一个变量brk，它指向堆的顶部。

![](/img/post/post-2018-02-28-41.jpg)

分配器将堆视为一组不同大小的块的集合来维护。每个块就是一个连续的虚拟内存片（chunk），要么是已分配的，要么是空闲的。

分配器有两种基本分割：

- 显式分配器（explicit allocator），要求应用显式地释放任何已分配的块。例如malloc函数。

- 隐式分配器（implicit allocator），也叫做垃圾收集器（garbage collector），自动释放未使用的已分配的块叫做垃圾手机（garbage collection）。

*9.9.4 碎片*

造成堆利用率很低的主要原因是一种称为碎片（fragmentation）的现象，当虽然有未使用的内存但不能用来满足分配请求时，就发生这种现象。

- 内部碎片是在一个已分配块比有效载荷大时发生的（我要5个字节，给了我8个字节）。

- 外部碎片是当空闲内存合计起来足够满足一个分配请求，但是没有一个单独的空闲块足够大可以来处理这个请求时发生的。

*9.9.6 隐式空闲链表*

![](/img/post/post-2018-02-28-42.jpg)

*9.9.7 放置已分配的块*

- 首次适配从开头搜索空闲链表，选择第一个合适的空闲块。有点事它趋向于将大的空闲块保留在链表的后面。缺点是它趋向于在靠近链表起始处留下小空闲块的“碎片”，增加了对较大块的搜索时间。

- 下一次适配是从上一次查询结束的地方开始。下一次适配比首次视频运行起来明显要快一些，然而内存利用率要低得多。

- 最佳适配检查每个空闲块，选择适合所需请求大小的最小空闲块。

*9.9.8 分割空闲块*

如果放置策略导致没有好的匹配，会分割空闲块

*9.9.9 获取额外的堆内存*

如果分配器无法为请求块找到合适的空闲块，就会通过合并相邻的空闲块创建更大的空闲块；如果依然不行，会通过sbrk函数，向内核请求额外的堆内存。分配器将额外的内存转化成一个大的空闲块，将这个块插入到空闲链表中，然后将被请求的块放置在这个新的空闲块中

*9.9.10 合并空闲块*

邻接的空闲块叫做假碎片，分配器合并他们为一个空闲块。立即合并是在每次一个块被释放时，就合并所有的相邻块。推迟合并是等到某个稍晚的时候再合并，如知道某个分配请求失败，扫描整个堆，合并所有的空闲块。

*9.9.11 带边界标记的合并*

将想要释放的块称为当前块，当前块的头部指向下一个块的头部，可以检查这个指针以判断下一个块是否是空闲的，如果是，就将它的大小简单地加到当前块头部的大小上，这两个块在常数时间内被合并。

边界标记（boundary tag）是指在每个块的结尾处添加一个脚部（头部的副本），从而向前合并可以在常数时间内完成。缺点是，这会产生额外的内存开销，尤其当程序操作许多个小块时。解决办法是，可以把前面块的已分配/空闲位存放在当前块中多出来的低位中，那么已分配的块就不需要脚部了。（没看懂，如果前面块比当前块大怎么办？）

![](/img/post/post-2018-02-28-43.jpg)

*9.9.13 显式空闲链表*

因为根据定义，程序不需要一个空闲块的主体，所以实现这个数据结构的指针可以存放在这些空闲块的主体里面。

![](/img/post/post-2018-02-28-44.jpg)

后进先出的顺序维护链表，将新释放的块放置在链表的开始处。结合首次适配的放置策略，分配器会最先检查最近使用过的块。

按地址顺序来维护链表，其中链表中的每个块的地址都小于它后继的地址。相比前者有更高的内存利用率，但释放一个块需要线性时间的搜索来定位。

*9.9.14 分离的空闲链表*

分离存储（segregated storage）就是维护多个空闲链表，其中每个链表中的块由大致相等的大小。一般的思路是将所有可能的块大小分成一些等价类，页叫做大小类（size class）。分配器维护着一个空闲链表数组，每个大小类一个空闲链表，按照大小的升序排列。当分配器需要一个大小为n的块时，它就搜索相应的空闲链表。如果不能找到合适的块与之匹配，它就搜索下一个列表。

- 简单分离存储

使用简单分离存储，每个大小类的空闲链表包含大小相等的块，每个块的大小就是这个大小类中最大元素的大小。为了分配一个给定大小的块，我们检查相应的空闲链表。如果链表非空，我们简单的分配其中第一块的全部。空闲块是不会分割以满足分配请求的。如果链表为空，分配器就向操作系统请求一个固定大小的额外内存片，将这个片分成大小相等的块，并将这些块链接起来形成新的空闲链表。要释放一个块，分配器只要简单的将这个块插入到相应的空闲链表的前部。

- 分离适配

使用这种方法，分配器维护着一个空闲链表的数组。每个空闲链表是和一个大小类相关联的，并且被组织成某种类型的显式或隐式链表。每个链表包含潜在的大小不同的块，这些块的大小时大小类的成员。

为了分配一个块，必须确定请求的大小类，并且对适当的空闲链表做首次适配，查找一个合适的块。如果找到了一个，那么久（可选地）分割它，并将剩余的部分插入到适当的空闲链表中。如果找不到，那么久搜索下一个更大的大小类的空闲链表。如果在没有，就向操作系统请求额外的堆内存。

- 伙伴系统

buddy system是分离适配的一个特例，其中每个大小类都是2的幂。


### 9.10 垃圾收集

垃圾收集器（garbage collector）是一种动态内存分配器，它自动释放程序不再需要的已分配块。

*9.10.1 垃圾收集器的基本知识*

垃圾收集器将内存视为一张有向可达图（reachability graph）。

![](/img/post/post-2018-02-28-45.jpg)

该图的节点被分成一组根节点（root node）和一组堆节点（heap node）。每个堆节点对应于堆中的一个已分配块。根节点对应于不再堆中的位置，包含指向堆中的指针。这些位置可以是寄存器、栈里的变量，或者是虚拟内存中读写数据区域内的全局变量。

当存在一条从任意根节点出发并到达堆节点的有向路径时，我们说它是可达的（reachable）。在任何时刻，不可达节点对应于垃圾，垃圾收集器的角色是维护可达图的某种表示，并通过释放不可达节点将他们返回给空闲链表，来定期的回收它们。

