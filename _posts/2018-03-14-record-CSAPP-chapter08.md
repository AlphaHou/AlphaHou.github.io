---
layout:     post
title:      reading-note-csapp
date:       2018-03-14 21:48:00
author:     "Hou"
header-img: "img/post-bg-computer-science.jpg"
tags:
    - note
    - csapp
---
第八章-异常控制流小结
============

从处理器通电开始，直到断电位置，程序计数器假设一个值的序列，a0,a1,...,an-1

其中，每个ak是某个响应的指令Ik的地址。每次从ak到ak+1的国度称为控制转移（control transfer）这样的控制转移序列叫做处理器的控制流（control flow）。


### 8.1 异常

异常（exception）是控制流中的突变，用来响应处理器状态中的某些变化。

![](/img/post/post-2018-02-28-32.jpg)

*8.1.1 异常处理*

当系统执行某个程序时，处理器检测到发生了一个事件，并且确定了响应的异常号k。随后，处理器触发异常，方法是执行间接过程调用，通过异常表的表目k，转到相应的处理程序。

*8.1.2 异常的类别*

![](/img/post/post-2018-02-28-33.jpg)


### 8.2 进程

异常是允许操作系统内核提供进程（process）概念的基本构造块。

进程的经典定义就是一个执行中程序的实力。系统中的每个程序都运行在某个进程的上下文中。上下文是由程序正确运行所需的状态组成。这个状态包括存放在内存中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。进行的两个关键抽象：

- 一个独立的逻辑控制流，它提供一个假象，好像我们的程序独占地使用处理器。

- 一个私有的地址空间，它提供一个假象，好像我们的程序独占地使用内存系统。

*8.2.1 逻辑控制流*

![](/img/post/post-2018-02-28-34.jpg)

*8.2.2 并发流*

一个逻辑流的执行在时间上与另一个流重叠，称为并发流（concurrent flow）。多个流并发地执行的一般现象被称为并发（concurrency）。一个进程和其他进程轮流运行的概念成为多任务（multitasking）。一个进程执行它的控制流的一部分的每一时间段叫做时间片（time slice）。因此，多任务也叫做时间分片（time slicing）。如果两个流并发地运行在不同的处理器核或者计算机上，我们称它们为并行流（parallel flow），他们并行地运行（running in parallel），且并行地执行（parallel execution）

*8.2.3 私有地址空间*

![](/img/post/post-2018-02-28-35.jpg)


*8.2.4 用户模式和内核模式*

处理器用来限制一个应用可以执行的指令以及它可以访问的地址空间范围的方法是用某个控制寄存器的模式位（mode bit）。该寄存器描述了进程当前享有的特权。当设置了模式位时，进程就运行在内核模式中（有时叫做超级用户模式）。一个运行在内核模式的进程可以执行指令集中的任何指令，并且可以访问系统中的任何内存位置。

没有设置模式位时，进程就运行在用户模式中。用户模式中的进程不允许执行特权指令（privileged instruction），比如停止处理器、改变模式位，或者发起一个I/O操作。也不允许用户模式中的进程之间应用地址空间中的内核区内的代码和数据。用户程序必须通过系统调用接口间接的访问内核代码和数据。

运行应用程序代码的进程初始时是在用户模式中的。进程从用户模式变为内核模式的唯一方法是通过诸如中断、故障或者陷入系统调用这样的异常。当异常发生时，控制传递到宜昌处理程序，处理器将模式从用户模式变为内核模式。处理程序运行在内核模式中，当他返回到应用程序代码时，处理器酒吧模式从内核模式改回到用户模式。

*8.2.5 上下文切换*

内核为每个进程维持一个上下文（context）。在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被枪战了的进程。这种决策就叫做调度（scheduling），时由内核中成为调度器（scheduler）的代码处理的。


### 8.4 进程控制

1. 获取进程ID

每一个进程都有一个唯一的正数进程ID（PID）

2. 创建和终止进程

从程序员的角度，我们可以认为进程总是处于下面三种状态之一：

- 运行。 进程要么在CPU上执行，要么在等待被执行且最终会被内核调度。

- 停止。进程的执行被挂起（suspended），且不会被调度。

- 终止。进程永远地停止了。有三种原因：收到一个信号，该信号默认行为时终止进程；从主程序返回；调用exit函数。

父进程通过fork函数创建子进程。新创建的子进程得到与父进程用户级虚拟地址空间相同的（但是独立的）一份副本，包括代码和数据段、堆、共享库以及用户栈。子进程还获得与父进程任何打开文件描述符相同的副本。他们最大的区别在于不同的PID。

fork函数有以下特点：

- 调用一次，返回两次。一次是返回到父进程，一次是返回到新创建的子进程。

- 并发执行。父进程和子进程是并发运行的独立进程。

- 相同但是独立的地址空间。

- 共享文件。父进程和子进程共享同一个文件。

对运行在单处理器上的程序，对应进程图中所有定点的拓扑排序（topological sort）表示程序中语句的一个可行的全序排列。

![](/img/post/post-2018-02-28-36.jpg)

3. 回收子进程

当一个进程由于某种原因终止时，内核并不是立即把他从系统中清除。相反，进程被保持在一种已终止的状态中，知道被他的父进程回收（reaped）。回收后，内核将子进程的推出状态传递给父进程，然后抛弃已终止的进程，从此时开始该进程就不存在了。一个终止了但还未被回收的进程称为僵死进程（zombie）。

如果一个父进程终止了，内核会安排init进程成为它的孤儿进程的养父。init进程的PID为1，是在系统启动时由内核创建的，它不会终止，是所有进程的祖先。


### 8.5 信号

一个信号就是一条小消息，它通知进程系统中发生了一个某种类型的时间。每种信号类型都对应于某种系统时间。

*8.5.1 信号术语*

- 发送信号。内核通过更新目的进程上下文中的某个状态，发送一个信号给目的进程。发送信号可以有如下两种原因：内核检测到一个系统事件，比如除零错误或者子进程终止；一个进程调用了kill函数，显式地要求内核发送一个信号给目的进程。

- 接收信号。当目的进程被内核强迫以某种方式对信号的发送做出反应时，它就接收了信号。进程可以忽略这个信号，终止或者通过执行一个称为信号处理程序（signal handler）的用户层函数补货这个信号。一个发出而没有被接收的喜好叫做待处理信号（pending signal）。在任何时刻，一种类型之多只会有一个待处理信号。如果一个进程有一个类型为k的待处理信号，那么任何接下来发送到这个进程的类型为k的信号都不会排队等待，他们只是被简单地丢弃。

*8.5.2 发送信号*

所有向进程发送信号的机制都是基于进程组（process group）这个概念的。

1. 进程组

每个进程都只属于一个进程组，进程组是由一个正整数进程组ID来标识的。默认的，一个子进程和他的父进程同属于一个进程组。

2. 用/bin/kill程序发送信号

/bin/kill程序可以向另外的进程发送任意的信号。比如，命令

>linux> bin/kill -9 15213

3. 从键盘发送信号

Unix shell使用作业（job）这个抽象概念来表示为对一条命令行求值而创建的进程。在任何时刻，至多只有一个前台作业和0个或多个后台作业。Ctrl+C终止前台进程组中的每个进程。Ctrl+Z挂起前台作业。

4. 用kill函数发送信号。

5. 用alarm函数发送信号

*8.5.3 接收信号*

当内核把进程p从内核模式切换到用户模式时，它会检查进程p的未被阻塞的待处理信号的集合。如果集合为空，那么内核将控制传递到p的逻辑控制流的下一条指令。如果非空，那么内核选择集合中的某个信号k（通常是最小的k），并且强制p接收信号k。完成后，控制就传递回p的逻辑控制流中的下一条指令。每个信号类型都有一个预定义的默认行为：

- 进程终止

- 进程终止并转储内存

- 进程停止知道被SIGCONT信号重启

- 进程忽略该信号


