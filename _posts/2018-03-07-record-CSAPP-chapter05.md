---
layout:     post
title:      reading-note-csapp
date:       2018-03-07 21:48:00
author:     "Hou"
header-img: "img/post-bg-computer-science.jpg"
tags:
    - note
    - csapp
---
第五章-优化程序性能小结
============


### 5.1 优化编译器的能力和局限性

编译器必须很小心地对程序只是用安全的优化，也就是说对于程序可能遇到的所有可能情况，在C语言标准提供的保证之下，优化后得到的程序和未优化的版本有一样的行为。

如在只执行安全的优化中，编译器必须假设不同的指针可能会指向内存中同一个位置，这个情况被称为内存别名使用（memory aliasing）。


### 5.2 表示程序性能

我们引入度量标准每元素的周期数（Cycles Per Element，CPE），作为一种表示程序性能并指导我们改进代码的方法。

处理器活动的顺序是由时钟控制的，时钟提供了某个频率的规律信号，通常用千兆赫兹（GHz），即十一周期每秒来表示。例如4GHz处理器，表示处理器时钟运行频率为每秒4 * 10^9个周期。每个时钟周期的时间是时钟频率的倒数。通常是以纳秒（nanosecond，1纳秒等于10^-9秒）或皮秒（picosecond，1皮秒等于10^-12秒）为单位的。例如4GHz处理器的时钟其周期为0.25纳秒，或250皮秒。


### 5.4 消除循环的低效率

代码移动（code motion），这类优化包括识别要执行多次（例如在循环里）但是计算结果不会改变的计算。因而可以将计算移动到代码前面不会被多次求值的部分。


### 5.5 减少过程调用


### 5.6 消除不必要的内存引用


### 5.7 理解现代处理器

*5.7.1 整体操作*

我们假象的处理器设计是不太严格地给予近期的Intel处理器的结构。这些处理器在工业界称为超标量（superscalar），意思是它可以在每个时钟周期执行多个操作，而且是乱序的（out-of0order），意思就是指令的执行顺序不一定要与他们在机器级程序中的顺序一致。整个设计有两个主要部分：指令控制单元（Instruction Control Unit，ICU）和执行单元（Execution Unit，EU）。前者负责从内存中独处指令序列，并根据这些指令序列生产一组针对程序数据的基本操作；而后者执行这些操作。

ICU从指令高速缓存（instruction cache）中读取指令，指令高速缓存是一个特殊的高速存储器，它包含最近访问的指令。通常，ICU会在当前正在执行的指令很早之前取指，这样它才有足够的时间对指令译码，并把操作发送到EU。不过一个问题是当程序遇到分支时，程序有两个可能的前进方向。一种可能会选择分支，控制被传递到分支目标。另一种可能是，不选择分支，控制被传递到指令序列的下一条指令。现代处理器采用了一种称为分支预测（branch prediction）的技术，处理器会猜测是否会选择分支，同时还预测分支的目标地址。使用投机执行（speculative execution）的技术，处理器会开始去除位于它预测的分支会跳到的地方的指令，并对指令译码，升值在它确定分支预测是否正确之前就开始执行这些操作。如果过后确定分支决策错误，会将状态重新设置到分支点的状态，并开始取出和执行另一个方向上的指令。标记为取指控制的块包括分支预测，已完成确定取那些指令的任务。

指令译码逻辑接受实际的程序指令，并将他们转换成一组基本操作（有时称为微操作）。

在ICU中，退一单元（retirement unit）记录正在进行的处理，并确保它遵守机器级程序的顺序语义。指令译码时，关于指令的信息被放置在一个先进先出的队里中。这个信息会一直保持在队列中，知道发生以下两个结果中的一个。首先，一旦一条指令的操作完成了，而且所有引起这条指令的分支点也都被实际执行了。另一方面，如果引起该指令的某个分支点预测错误，这条指令会被清空（flushed），丢弃所有计算出来的结果。

控制操作数在执行单元间传送的最常见的机制称为寄存器重命名（register renaming）。当一条更新寄存器r的指令译码时，产生标记t，得到一个指向该操作结果的唯一标识符。条目（r，t）被加入到一张表中，该表维护着每个程序寄存器r与会更新该寄存器的操作的标记t之间的关联。当随后以寄存器r作为操作数的指令译码时，会常数一个结果（v，t），知名标记为t的操作产生值v。所有等待t作为源的操作都能使用v作为源值，这就是一种形式的数据转发。通过这种机制，值可以从一个操作直接转发到另一个操作，而不是写到寄存器文件在读出来，使得第二个操作能够在第一个操作完成后尽快开始。

*5.7.2 功能单元的性能*

延迟（latency）表示完成运算所需要的总时间；发射时间（issue time）表示两个连续的同类型的运算之间需要的最小时钟周期数；容量（capacity）表示能够执行该运算的功能单元的数量。

流水线化的功能单元实现为一系列的阶段（stage），每个阶段完成一部分的运算。例如，一个典型的浮点加法器包含三个阶段（所以有三个周期的延迟）：一个阶段处理指数值，一个阶段将小数相加，而另一个阶段对结果进行舍入。发射时间为1的功能单元被称为完全流水线化的（fully pipelined）：每个时钟周期可以开始一个新的运算。

表达发射时间的一种更常见的方法是指明这个功能单元的最大吞吐量，定义为发射时间的倒数。

*5.7.3 处理器操作的抽象模型*

作为分析在现代处理器上执行的机器级程序性能的一个工具，我们会使用程序的数据流（data-flow）表示，这是一种图形化的表示方法，展现了不同操作之间的数据相关时如何限制它们执行顺序的。这些限制形成了途中的关键路径（critical path），这是执行一组机器指令所需时钟周期数的一个下界。

![](/img/post/post-2018-02-28-12.jpg)

对于形成循环的代码片段，我们可以将访问到的寄存器分为四类：
- 只读，这些寄存器只用作源值，可以作为数据，也可以用来计算内存地址，但是在循环中它们是不会被修改的。

- 只写，这些寄存器作为数据传送操作的目的

- 局部，这些寄存器在循环内部被修改和使用，迭代与迭代之间不相关。

- 循环，对于循环来说，这些寄存器即作为源值，又作为目的，一次迭代中产生的值会在另一次迭代中用到。

![](/img/post/post-2018-02-28-13.jpg)

在这个函数中，左边的链会成为关键路径，制约程序的性能（乘法的延迟远大于加法）。


### 5.8 循环展开

循环展开是一种程序变换，通过增加每次迭代计算的元素的数量，减少循环的迭代次数。循环展开能够从两个方面改进程序的性能。首先，它减少了不直接有助于程序结果的操作的数量，例如循环计算和条件分支。第二，它提供了一些方法，可以进一步变化代码，减少整个计算中关键路径上的操作数量。（其实就是减少了循环中的加法操作）


### 5.9 提高并行性

*5.9.1 多个累积变量*

通过将一组合并运算分割成两个或更多的部分，并在最后合并结果来提高性能。（因为这样一来，我们就不需要等第一个运算结束再开始下一个运算，而是并行地进行这两个运算）K * K 循环并行展开能够接近或达到其吞吐量界限。

*5.9.2 重新结合变换*

简单来说，通过改变计算次序，将累计值的计算放在最后，可以省去等待累计值计算的时间。


### 5.11 一些限制因素

1. 寄存器溢出，如果并行度p超过了可用的寄存器数量，那么编译器会诉诸溢出（spolling），将某些临时值存放到内存中，通常是在运行时堆栈上分配空间。

2. 分支预测和预测错误处罚，处理器用分支预测会处理得很糟糕。


### 5.12 理解内存性能

1. 加载的性能：一个包含加载操作的程序的性能即依赖于流水线的能力，也依赖于加载单元的延迟。

2. 存储的性能：存储（store）操作，将一个寄存器值写到内存。


### 5.13 应用：性能提高技术

1. 高级设计。选择适当的算法和数据结构。

2. 基本编码原则：消除连续的函数调用，尽可能将计算移到循环外；消除不必要的内存引用，引入临时变量来保存中间结果，只有在最后的值即算出来时，才将结果存放到数组或全局变量中。

3. 低级优化。结构化代码以利用硬件功能。展开循环，降低开销；通过使用例如多个累计变量和重新结合等技术；用功能性的风格重写条件操作。


### 5.14 确认和消除性能瓶颈

1. 程序剖析（profiling）运行程序的一个版本，用来确定程序的各个部分需要多少时间。剖析的一个有力之处在于可以在现实的基准数据（benchmark data）上运行实际程序的同时，进行剖析。

2. 使用剖析程序的到的结果来优化。



